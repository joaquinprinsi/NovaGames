const { EmbedBuilder } = require('discord.js');
const events = require('events');

module.exports = class FishyGame extends events {
  constructor(options = {}) {
    if (!options.isSlashGame) options.isSlashGame = false;
    if (!options.message) throw new TypeError('NO_MESSAGE: No se proporcion√≥ la opci√≥n de mensaje.');
    if (typeof options.message !== 'object') throw new TypeError('INVALID_MESSAGE: la opci√≥n de mensaje debe ser un objeto.');
    if (typeof options.isSlashGame !== 'boolean') throw new TypeError('INVALID_COMMAND_TYPE: la opci√≥n isSlashGame debe ser un booleano.');

    if (!options.embed) options.embed = {};
    if (!options.embed.title) options.embed.title = 'Inventario de Pesca';
    if (!options.embed.color) options.embed.color = '#5865F2';

    if (!options.player) options.player = {};
    if (!options.player.id) options.player.id = options.message[options.isSlashGame ? 'user' : 'author'].id;
    if (!options.player.balance && options.player.balance !== 0) options.player.balance = 50;
    if (!options.player.fishes) options.player.fishes = {};

    if (!options.fishes) options.fishes = {};
    if (!options.fishes.junk) options.fishes.junk = { emoji: 'üîß', price: 5 };
    if (!options.fishes.common) options.fishes.common = { emoji: 'üêü', price: 10 };
    if (!options.fishes.uncommon) options.fishes.uncommon = { emoji: 'üê†', price: 20 };
    if (!options.fishes.rare) options.fishes.rare = { emoji: 'üê°', price: 50 };

    if (!options.fishyRodPrice) options.fishyRodPrice = 10;
    if (!options.catchMessage) options.catchMessage = '¬°Has atrapado un {fish}! Pagaste {amount} monedas por la ca√±a de pescar.';
    if (!options.sellMessage) options.sellMessage = 'Has vendido {amount}x {fish} {type} por un total de {price} monedas.';
    if (!options.noBalanceMessage) options.noBalanceMessage = 'No tienes suficiente saldo para alquilar una ca√±a de pescar.';
    if (!options.invalidTypeMessage) options.invalidTypeMessage = 'El tipo de pez solo puede ser: chatarra, com√∫n, poco com√∫n o raro.';
    if (!options.invalidAmountMessage) options.invalidAmountMessage = 'La cantidad debe estar entre 0 y el m√°ximo de peces que tienes.';
    if (!options.noItemMessage) options.noItemMessage = 'No tienes ning√∫n art√≠culo de este tipo en tu inventario.';

    if (typeof options.embed !== 'object') throw new TypeError('INVALID_EMBED: la opci√≥n de embed debe ser un objeto.');
    if (typeof options.embed.title !== 'string') throw new TypeError('INVALID_EMBED: el t√≠tulo del embed debe ser una cadena.');
    if (typeof options.embed.color !== 'string') throw new TypeError('INVALID_EMBED: el color del embed debe ser una cadena.');
    if (typeof options.player !== 'object') throw new TypeError('INVALID_PLAYER: la opci√≥n de jugador debe ser un objeto.');
    if (typeof options.player.id !== 'string') throw new TypeError('INVALID_PLAYER: la id del jugador debe ser una cadena.');
    if (typeof options.player.fishes !== 'object') throw new TypeError('INVALID_PLAYER: los peces del jugador deben ser un objeto.');
    if (typeof options.player.balance !== 'number') throw new TypeError('INVALID_PLAYER: el dinero del jugador debe ser un n√∫mero.');
    if (typeof options.fishyRodPrice !== 'number') throw new TypeError('INVALID_PRICE: el precio de la ca√±a de pescar debe ser un n√∫mero.');
    if (typeof options.catchMessage !== 'string') throw new TypeError('INVALID_MESSAGE: la opci√≥n de mensaje de captura debe ser una cadena.');
    if (typeof options.sellMessage !== 'string') throw new TypeError('INVALID_MESSAGE: la opci√≥n de mensaje de venta debe ser una cadena.');
    if (typeof options.noBalanceMessage !== 'string') throw new TypeError('INVALID_MESSAGE: la opci√≥n de mensaje de saldo insuficiente debe ser una cadena.');
    if (typeof options.invalidTypeMessage !== 'string') throw new TypeError('INVALID_MESSAGE: la opci√≥n de mensaje de tipo inv√°lido debe ser una cadena.');
    if (typeof options.invalidAmountMessage !== 'string') throw new TypeError('INVALID_MESSAGE: la opci√≥n de mensaje de cantidad inv√°lida debe ser una cadena.');
    if (typeof options.noItemMessage !== 'string') throw new TypeError('INVALID_MESSAGE: la opci√≥n de mensaje de no hay art√≠culo debe ser una cadena.');

    super();
    this.options = options;
    this.message = options.message;
    this.player = options.player;
    this.fishes = options.fishes;
    if (options.isSlashGame || !options.message.author) {
      this.message.author = this.message.user;
      this.options.isSlashGame = true;
    }
  }

  async sendMessage(content) {  
    if (this.options.isSlashGame) {
      if (!this.message.deferred) return await this.message.reply(content).catch(e => {});
      else return await this.message.editReply(content).catch(e => {});
    } else {
      return await this.message.channel.send(content).catch(e => {});
    }
  }

  async catchFish() {
    let fishType = 'rare';
    const fishId = Math.floor(Math.random() * 10) + 1;

    if (fishId < 5) fishType = 'junk';
    else if (fishId < 8) fishType = 'common';
    else if (fishId < 10) fishType = 'uncommon';

    const fish = this.fishes[fishType];
    if (this.player.balance < this.options.fishyRodPrice) return this.sendMessage({ content: this.options.noBalanceMessage });
    const content = this.options.catchMessage.replace('{fish}', fish.emoji).replace('{amount}', this.options.fishyRodPrice);

    this.player.balance -= this.options.fishyRodPrice;
    this.player.fishes[fishType] = (this.player.fishes[fishType] || 0) + 1;

    this.emit('catchFish', { player: this.player, fishType: fishType, fish: fish });
    return await this.sendMessage({ content: content });
  }

  async sellFish(type, amount) {
    if (!this.fishes[type]) return this.sendMessage({ content: this.options.invalidTypeMessage });
    if (!this.player.fishes[type]) return this.sendMessage({ content: this.options.noItemMessage });
    if (parseInt(amount) < 0 || parseInt(amount) > this.player.fishes[type]) return this.sendMessage({ content: this.options.invalidAmountMessage });

    const fish = this.fishes[type];
    const content = this.options.sellMessage.replace('{amount}', amount).replace('{type}', this.translateFishType(type)).replace('{fish}', fish.emoji).replace('{price}', (fish.price * amount));

    this.player.fishes[type] -= amount;
    this.player.balance += (fish.price * amount);

    this.emit('sellFish', { player: this.player, fishType: type, fish: fish });
    return await this.sendMessage({ content: content });
  }

  async fishyInventory() {
    const fishes = (['common', 'uncommon', 'rare'].map(e => `> **${this.fishes[e].emoji} ${this.translateFishType(e)}** ‚Äî ${this.player.fishes[e] || 0}`).join('\n\n'));

    const embed = new EmbedBuilder()
      .setColor(this.options.embed.color)
      .setTitle(this.options.embed.title)
      .setAuthor({ name: this.message.author.tag, iconURL: this.message.author.displayAvatarURL({ dynamic: true }) })
      .setDescription(`${fishes}\n\n> **${this.fishes.junk.emoji} Chatarra** ‚Äî ${this.player.fishes.junk || 0}`)
      .addFields({ name: 'Saldo', value: `${this.player.balance}` })
      .setTimestamp();

    return await this.sendMessage({ embeds: [embed] });
  }

  translateFishType(type) {
    const translations = {
      junk: 'Chatarra',
      common: 'Com√∫n',
      uncommon: 'Poco com√∫n',
      rare: 'Raro'
    };
    return translations[type] || type;
  }
}
