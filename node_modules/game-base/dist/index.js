class h {
  constructor() {
    this.phases = Object.freeze({
      head: /* @__PURE__ */ new Set(),
      update: /* @__PURE__ */ new Set(),
      render: /* @__PURE__ */ new Set(),
      tail: /* @__PURE__ */ new Set()
    }), this.#e = !1, this.#t = null, this.#s = null, this.#r = ["head", "update", "render", "tail"], this.tick = (e) => {
      this.#t = requestAnimationFrame(this.tick);
      const t = this.#s === null ? 0 : e - this.#s;
      for (const s of this.#r)
        for (const r of this.phases[s])
          try {
            r(t);
          } catch (i) {
            console.error(i);
          }
      this.phases.head.clear(), this.phases.tail.clear();
    }, this.start = () => {
      if (this.running) {
        console.warn("Ticker already running");
        return;
      }
      this.#e = !0, this.tick(performance.now());
    }, this.stop = () => {
      cancelAnimationFrame(this.#t), this.#t = null, this.#e = !1;
    };
  }
  #e;
  get running() {
    return this.#e;
  }
  #t;
  #s;
  #r;
  register(e, t = "render") {
    this.phases[t].add(e);
  }
  unregister(e, t = "render") {
    this.phases[t].delete(e);
  }
}
export {
  h as Ticker
};
//# sourceMappingURL=index.js.map
